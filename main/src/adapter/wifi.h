#pragma once

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include "adapter/queue.h"

#include "core/error.h"

enum {
    /** Length of a MAC address */
    MAC_ADDRESS_LENGTH = 6,

    /** Length of an IPv4 address */
    IPV4_ADDRESS_LENGTH = 4,

    /** Maximum length for a SSID. Does not take into account string terminator! */
    WIFI_SSID_MAX_LENGTH = 32,

    /** Maximum length for a passphrase. Does not take into account string terminator! */
    WIFI_PASSWORD_MAX_LENGTH = 64,
};

/**
 * Structure that represents an IPv4 address
 */
typedef union {
    /** Value of the IP address as little-endian integer */
    uint32_t value;

    /** Value of the IP address as bytes */
    uint8_t bytes[IPV4_ADDRESS_LENGTH];
} IPv4Address;

/** Checks if two IPv4Address are equal */
#define IPV4_EQ(a, b) ((a).value == (b).value)

/** Constructs an IPv4Address from bytes */
#define mkIPv4(a, b, c, d) ((IPv4Address){.bytes = {(a), (b), (c), (d)}})

/**
 * Wi-Fi regulator domain
 */
typedef enum {
    REGULATOR_DOMAIN_UNDEFINED = 0,
    REGULATOR_DOMAIN_FCC = 1,
    REGULATOR_DOMAIN_ETSI = 2,
    REGULATOR_DOMAIN_TELEC = 3,
    REGULATOR_DOMAIN_KCC = 4,
    REGULATOR_DOMAIN_SRRC = 5,
} WiFiRegulatorDomain;

/**
 * Configuration for the IPv4 of an interface
 */
typedef struct {
    /** IPv4 address. Set to 0 in case of using DHCP */
    IPv4Address address;

    /** IPv4 netmask. Set to 0 in case of using DHCP */
    IPv4Address netmask;

    /** IPv4 gateway. Set to 0 in case of using DHCP */
    IPv4Address gateway;

    /** IPv4 DNS server. Set to 0 in case of using DHCP */
    IPv4Address dns;
} IPv4Config;

/**
 * Type of WiFi security
 */
typedef enum {
    WIFI_SECURITY_OPEN,
    WIFI_SECURITY_WEP,
    WIFI_SECURITY_WPA_PSK,
    WIFI_SECURITY_WPA2_PSK,
    WIFI_SECURITY_WPA_WPA2_PSK,
    WIFI_SECURITY_WPA3_PSK,
    WIFI_SECURITY_WPA2_WPA3_PSK,
    WIFI_SECURITY_WPA2_ENTERPRISE,
    WIFI_SECURITY_UNSUPPORTED = 0xFF,
} WiFiSecurityType;

/**
 * Wi-Fi network configuration structure.
 */
typedef struct {
    /** regulator domain for the network */
    WiFiRegulatorDomain regulatorDomain;

    /** type of network security to use */
    WiFiSecurityType securityType;

    /** SSID of the Wi-Fi network */
    char ssid[WIFI_SSID_MAX_LENGTH + 1];

    /** passphrase of the Wi-Fi network (if required) */
    char passphrase[WIFI_PASSWORD_MAX_LENGTH + 1];

    /** IP for the interface */
    IPv4Config ipv4;
} WiFiNetwork;

/**
 * Events generated by the interface
 */
typedef enum {
    /** The STA is connected to the AP. An IP may not be jet available */
    DRIVER_WIFI_EVENT_STA_CONNECTED = 0xFF,

    /** The STA is disconnected from the AP. Payload is the disconnect reason. */
    DRIVER_WIFI_EVENT_STA_DISCONNECTED,

    /** An IP address for the STA is assigned */
    DRIVER_WIFI_EVENT_STA_GOT_IP,

    /** The IP address for the STA is lost */
    DRIVER_WIFI_EVENT_STA_LOST_IP,

    /** An IP address was assigned to an AP client */
    DRIVER_WIFI_EVENT_AP_IP_ASSIGNED,
} WiFiEvent;

/**
 * Initialize the Wi-Fi driver
 *
 * @param eventQueue queue where WifiEvents are sent
 * @returns the Wi-Fi handle if success, otherwise an error
 */
ErrorCode WiFi_Init(Queue *eventQueue);

/**
 * Starts the connection to the STA interface. Will keep trying to
 * connect as long as the interface is not stopped.
 *
 * @param network the network to connect to
 * @returns SUCCESS if connection started
 */
ErrorCode WiFi_StartSta(const WiFiNetwork *network);

/**
 * Stops the connection with the STA interface;
 *
 * @returns SUCCESS if the connection is stopped
 */
ErrorCode WiFi_StopSta(void);
